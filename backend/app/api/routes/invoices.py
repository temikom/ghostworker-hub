"""Invoice API routes"""
from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func
from uuid import UUID
from typing import Optional
from datetime import datetime, date
from pydantic import BaseModel
from decimal import Decimal
from typing import List

from app.api.deps import get_db, get_current_user, PaginationParams
from app.models import Invoice, InvoiceItem, InvoiceStatus, Order, Customer, User

router = APIRouter()


# Pydantic schemas
class InvoiceItemCreate(BaseModel):
    description: str
    quantity: Decimal
    unit_price: Decimal


class InvoiceCreate(BaseModel):
    customer_id: UUID
    order_id: Optional[UUID] = None
    due_date: Optional[date] = None
    notes: Optional[str] = None
    items: List[InvoiceItemCreate]


class InvoiceUpdate(BaseModel):
    status: Optional[str] = None
    due_date: Optional[date] = None
    notes: Optional[str] = None


class InvoiceItemResponse(BaseModel):
    id: UUID
    description: str
    quantity: Decimal
    unit_price: Decimal
    total: Decimal

    class Config:
        from_attributes = True


class InvoiceResponse(BaseModel):
    id: UUID
    invoice_number: str
    customer_id: UUID
    order_id: Optional[UUID]
    status: str
    subtotal: Decimal
    tax: Decimal
    total: Decimal
    currency: str
    due_date: Optional[date]
    paid_at: Optional[datetime]
    pdf_url: Optional[str]
    notes: Optional[str]
    created_at: datetime
    items: List[InvoiceItemResponse] = []

    class Config:
        from_attributes = True


@router.get("")
async def list_invoices(
    status: Optional[str] = None,
    customer_id: Optional[UUID] = None,
    pagination: PaginationParams = Depends(),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """List all invoices for the team"""
    query = select(Invoice).where(Invoice.team_id == current_user.team_id)
    
    if status:
        query = query.where(Invoice.status == status)
    if customer_id:
        query = query.where(Invoice.customer_id == customer_id)
    
    # Count total
    count_query = select(func.count()).select_from(query.subquery())
    total = await db.scalar(count_query)
    
    # Paginate
    query = query.order_by(Invoice.created_at.desc())
    query = query.offset(pagination.offset).limit(pagination.page_size)
    
    result = await db.execute(query)
    invoices = result.scalars().all()
    
    return {
        "invoices": invoices,
        "total": total,
        "page": pagination.page,
        "page_size": pagination.page_size
    }


@router.get("/{invoice_id}")
async def get_invoice(
    invoice_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get invoice details with items"""
    result = await db.execute(
        select(Invoice).where(
            Invoice.id == invoice_id,
            Invoice.team_id == current_user.team_id
        )
    )
    invoice = result.scalar_one_or_none()
    
    if not invoice:
        raise HTTPException(status_code=404, detail="Invoice not found")
    
    # Get items
    items_result = await db.execute(
        select(InvoiceItem).where(InvoiceItem.invoice_id == invoice_id)
    )
    items = items_result.scalars().all()
    
    return {
        **InvoiceResponse.model_validate(invoice).model_dump(),
        "items": [InvoiceItemResponse.model_validate(item) for item in items]
    }


@router.post("")
async def create_invoice(
    data: InvoiceCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Create a new invoice"""
    # Verify customer exists
    customer_result = await db.execute(
        select(Customer).where(
            Customer.id == data.customer_id,
            Customer.team_id == current_user.team_id
        )
    )
    if not customer_result.scalar_one_or_none():
        raise HTTPException(status_code=404, detail="Customer not found")
    
    # Calculate totals
    subtotal = sum(item.quantity * item.unit_price for item in data.items)
    tax = subtotal * Decimal("0.0")  # Configure tax rate as needed
    total = subtotal + tax
    
    # Create invoice (invoice_number generated by trigger)
    invoice = Invoice(
        team_id=current_user.team_id,
        customer_id=data.customer_id,
        order_id=data.order_id,
        status=InvoiceStatus.DRAFT,
        subtotal=subtotal,
        tax=tax,
        total=total,
        due_date=data.due_date,
        notes=data.notes
    )
    db.add(invoice)
    await db.flush()
    
    # Create invoice items
    for item_data in data.items:
        item = InvoiceItem(
            invoice_id=invoice.id,
            description=item_data.description,
            quantity=item_data.quantity,
            unit_price=item_data.unit_price,
            total=item_data.quantity * item_data.unit_price
        )
        db.add(item)
    
    await db.commit()
    await db.refresh(invoice)
    
    return invoice


@router.put("/{invoice_id}")
async def update_invoice(
    invoice_id: UUID,
    data: InvoiceUpdate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Update invoice"""
    result = await db.execute(
        select(Invoice).where(
            Invoice.id == invoice_id,
            Invoice.team_id == current_user.team_id
        )
    )
    invoice = result.scalar_one_or_none()
    
    if not invoice:
        raise HTTPException(status_code=404, detail="Invoice not found")
    
    if data.status:
        invoice.status = data.status
        if data.status == InvoiceStatus.PAID.value:
            invoice.paid_at = datetime.utcnow()
    if data.due_date is not None:
        invoice.due_date = data.due_date
    if data.notes is not None:
        invoice.notes = data.notes
    
    await db.commit()
    await db.refresh(invoice)
    
    return invoice


@router.post("/{invoice_id}/send")
async def send_invoice(
    invoice_id: UUID,
    background_tasks: BackgroundTasks,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Send invoice to customer via email"""
    result = await db.execute(
        select(Invoice).where(
            Invoice.id == invoice_id,
            Invoice.team_id == current_user.team_id
        )
    )
    invoice = result.scalar_one_or_none()
    
    if not invoice:
        raise HTTPException(status_code=404, detail="Invoice not found")
    
    # Update status
    invoice.status = InvoiceStatus.SENT
    await db.commit()
    
    # TODO: Add background task to send email
    # background_tasks.add_task(send_invoice_email, invoice.id)
    
    return {"message": "Invoice sent successfully"}


@router.post("/{invoice_id}/mark-paid")
async def mark_invoice_paid(
    invoice_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Mark invoice as paid"""
    result = await db.execute(
        select(Invoice).where(
            Invoice.id == invoice_id,
            Invoice.team_id == current_user.team_id
        )
    )
    invoice = result.scalar_one_or_none()
    
    if not invoice:
        raise HTTPException(status_code=404, detail="Invoice not found")
    
    invoice.status = InvoiceStatus.PAID
    invoice.paid_at = datetime.utcnow()
    await db.commit()
    
    return {"message": "Invoice marked as paid"}


@router.delete("/{invoice_id}")
async def delete_invoice(
    invoice_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Delete invoice (only drafts)"""
    result = await db.execute(
        select(Invoice).where(
            Invoice.id == invoice_id,
            Invoice.team_id == current_user.team_id
        )
    )
    invoice = result.scalar_one_or_none()
    
    if not invoice:
        raise HTTPException(status_code=404, detail="Invoice not found")
    
    if invoice.status != InvoiceStatus.DRAFT:
        raise HTTPException(status_code=400, detail="Can only delete draft invoices")
    
    await db.delete(invoice)
    await db.commit()
    
    return {"success": True}


@router.get("/stats/summary")
async def get_invoice_stats(
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get invoice statistics"""
    # Total invoices by status
    stats_query = select(
        Invoice.status,
        func.count(Invoice.id).label('count'),
        func.sum(Invoice.total).label('total')
    ).where(
        Invoice.team_id == current_user.team_id
    ).group_by(Invoice.status)
    
    result = await db.execute(stats_query)
    stats = result.all()
    
    return {
        "by_status": [
            {"status": row.status, "count": row.count, "total": float(row.total or 0)}
            for row in stats
        ]
    }
